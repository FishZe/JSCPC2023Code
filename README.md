## A.Today's Word

### 题意:

给定一个字符串, 给定一个特定操作方式: `该字符串前半段 + 该字符串自己 + 该字符串后半段求next(每一个字符向后移动一个)`, 组成一个新字符串, 求经过`10^100`次这样的操作后, 新字符串的后`m`位是什么

### 思路

题意说明了字符串一定是偶数长度的, 根据给定的数据范围, 可以确定最终的答案只与后半段字符串有关, 那么我们可以在一开始直接截取原字符串的后半段, 通过模拟该变化, 当字符串长度达到`m`后, 计算距离`10^100`次变化还差多少次变化即可. 由于每`26`次求`next`后都会变为其本身, 那么我们只要知道`10^100 MOD 26`的大小, 即可直接求出最终答案

## F.Timaeus

### 题意

有`a`个原料, 通过`b`个原料可以生成一个产品, 有两种`buff`: `p%`的概率同样的原料生成`2`个, `q%`的概率在生成后拿回一个原料, 每次生成只能选择一个`buff`, 求最终生成产品个数的期望

### 思路

很显然是个`dp`, 定义`dp[i]`为有`i`个原料时生成产品个数的期望, 那么转移公式为: `dp[i] = max(dp[i - b] + (1 * p%), 1 + q% * dp[i - b + 1] + (1 - q%) * dp[i - b])`, 表示每次取两种`buff`的最大值: 多生成一个, 从`dp[i - b]`转移而来, 和有`q%`从`dp[i - b + 1]`转移而来的概率和`1 - q%`从`dp[i - b]` 转移而来. 然而, 还需要考虑一种特殊情况: `b == 1`时, 会有一种: 每次都有`q%`的概率不用消耗原料就可以生成结果的情况, 对于这种情况应当修改`q`部分的公式, 那么对于使用`1`个原料可以生成的结果的期望为`1 / (1 - q%)`, 因此对于这种情况`q`部分的公式应当为`1 / (1 - q%) + dp[i - b]`.

## H.Neil's Machine

### 题意

两个字符串`s`和`t`, 一次修改可以把从某个位置到最后的所有字符向后位移若干位, 求从`s`修改为`t`的最少操作次数.

### 思路

难度仅次于签到题的题目, 对每一位进行判断, 计算`s`和`t`相应位上的差值, 如果差值和前一位变化, 那么就需要一次操作, 记录次数即可.

## I.Elevator

### 题意

一个电梯有`n`个人, 每个人都有一个想去的楼层, 共有`m`个楼层需要停靠, 求一层楼最多想去的人数.

### 思路

签到题. 对于其他`m - 1`个楼层每层`1`个人, 那么一层楼最多的想去人数为`n - (m - 1) = n - m + 1`.

## J.Similarity (Easy Version) 

### 题意

每组样例有`n`个字符串, 求任意两个字符串中相同子串的最长长度.

### 思路

仅次于仅次于签到题题目的难度. 数据范围很小, 直接枚举所有子串即可. 开一个`set`记录之前所有子串， 开一个`set`记录当前字符串所有的子串, 如果当前的子串存在于之前的`set`中, 更新答案, 子串枚举完成后把所有子串放入前一个`set`即可.

## K.Similarity (Hard Version)

### 题意

上一题反过来, 给定字符串个数, 给定最长相同子串长度, 给定字符串长度, 生成字符串满足要求.

### 思路

首先生成两个字符串, 使得他们的相同子串长度满足要求, 所以让一个全是`a`, 一个为`aaabbb`, 那么相同子串的长度就确定了. 然后生成剩下的字符串: 两重循环生成长度为`2`的字符串: `cd ce cf...yz zz`长度不够循环自身即可. 需要判断的特殊情况: 1. 最长长度大于等于要求的字符串的长度 2. `m == 1`时, 如果要求的字符串个数大于`26`, 那么就无法满足生成个数要求.